---
mode: agent
---

> [!abstract] Hướng dẫn toàn diện tạo Custom Obsidian Plugin với Shiki  
> Tổng hợp từng bước chi tiết để tạo custom plugin render code blocks cho Obsidian sử dụng **Shiki** syntax highlighter, từ setup project đến implementation features nâng cao.

# Bước 1: Setup Project

### Cấu trúc thư mục

```
shiki-codeblock/
├── src/
│   ├── main.ts
│   ├── settings.ts
│   ├── highlighter.ts
│   ├── parser.ts
│   ├── transformers.ts
│   └── types.ts
├── styles.css
├── manifest.json
├── package.json
├── tsconfig.json
└── esbuild.config.mjs
```

## Package.json Configuration

```json
{
	"name": "shiki-codeblock",
	"version": "1.0.0",
	"description": "Custom Shiki code block highlighter for Obsidian",
	"main": "main.js",
	"scripts": {
		"dev": "node esbuild.config.mjs",
		"build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production",
		"version": "node version-bump.mjs && git add manifest.json versions.json"
	},
	"keywords": [],
	"author": "",
	"license": "MIT",
	"devDependencies": {
		"@types/node": "^16.11.6",
		"@typescript-eslint/eslint-plugin": "5.29.0",
		"@typescript-eslint/parser": "5.29.0",
		"builtin-modules": "3.3.0",
		"esbuild": "0.17.3",
		"obsidian": "latest",
		"tslib": "2.4.0",
		"typescript": "4.7.4"
	},
	"dependencies": {
		"shiki": "^1.0.0"
	}
}
```

## Manifest.json

```json
{
	"id": "shiki-codeblock",
	"name": "Shiki Codeblock",
	"version": "1.0.0",
	"minAppVersion": "0.15.0",
	"description": "Add Shiki codeblock to Obsidian.",
	"author": "terasumi",
	"authorUrl": "https://tongducthanhnam.id.vn",
	"fundingUrl": "https://tongducthanhnam.id.vn",
	"isDesktopOnly": false
}
```

## ESBuild Configuration

```javascript
// esbuild.config.mjs
import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";

const context = await esbuild.context({
	banner: { js: banner },
	entryPoints: ["src/main.ts"],
	bundle: true,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins,
	],
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outfile: "main.js",
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
```

# Bước 2: TypeScript Types Definition

## src/types.ts

```typescript
export interface ShikiPluginSettings {
	defaultTheme: string;
	defaultDarkTheme: string;
	defaultLightTheme: string;
	enableLineNumbers: boolean;
	enableInlineHighlight: boolean;
	enableFolding: boolean;
	customThemePath: string;
	languages: string[];
	themes: string[];
	cacheEnabled: boolean;
}

export interface CodeBlockConfig {
	language: string;
	highlightLines: number[];
	showLineNumbers: boolean;
	startLineNumber: number;
	title?: string;
	fold: boolean;
	unfold: boolean;
	exclude: boolean;
	customTheme?: string;
}

export interface HighlightRange {
	start: number;
	end: number;
	type: "line" | "text";
	text?: string;
}

export interface CacheEntry {
	html: string;
	timestamp: number;
}

export type ThemeMode = "light" | "dark";
```

# Bước 3: Settings Management

## src/settings.ts

```typescript
import { App, PluginSettingTab, Setting } from "obsidian";
import ShikiCustomPlugin from "./main";
import { ShikiPluginSettings } from "./types";

export const DEFAULT_SETTINGS: ShikiPluginSettings = {
	defaultTheme: "dark-plus",
	defaultDarkTheme: "dark-plus",
	defaultLightTheme: "light-plus",
	enableLineNumbers: false,
	enableInlineHighlight: true,
	enableFolding: true,
	customThemePath: "",
	languages: [
		"javascript",
		"typescript",
		"python",
		"cpp",
		"java",
		"html",
		"css",
	],
	themes: ["dark-plus", "light-plus", "github-dark", "github-light"],
	cacheEnabled: true,
};

export class ShikiSettingTab extends PluginSettingTab {
	plugin: ShikiCustomPlugin;

	constructor(app: App, plugin: ShikiCustomPlugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const { containerEl } = this;
		containerEl.empty();

		containerEl.createEl("h2", { text: "Shiki Custom Settings" });

		// Theme Settings
		new Setting(containerEl)
			.setName("Default Dark Theme")
			.setDesc("Theme to use in dark mode")
			.addDropdown((dropdown) =>
				dropdown
					.addOptions({
						"dark-plus": "Dark Plus",
						"github-dark": "GitHub Dark",
						dracula: "Dracula",
						monokai: "Monokai",
					})
					.setValue(this.plugin.settings.defaultDarkTheme)
					.onChange(async (value) => {
						this.plugin.settings.defaultDarkTheme = value;
						await this.plugin.saveSettings();
					})
			);

		new Setting(containerEl)
			.setName("Default Light Theme")
			.setDesc("Theme to use in light mode")
			.addDropdown((dropdown) =>
				dropdown
					.addOptions({
						"light-plus": "Light Plus",
						"github-light": "GitHub Light",
						"min-light": "Min Light",
					})
					.setValue(this.plugin.settings.defaultLightTheme)
					.onChange(async (value) => {
						this.plugin.settings.defaultLightTheme = value;
						await this.plugin.saveSettings();
					})
			);

		// Feature Settings
		new Setting(containerEl)
			.setName("Enable Line Numbers")
			.setDesc("Show line numbers by default")
			.addToggle((toggle) =>
				toggle
					.setValue(this.plugin.settings.enableLineNumbers)
					.onChange(async (value) => {
						this.plugin.settings.enableLineNumbers = value;
						await this.plugin.saveSettings();
					})
			);

		new Setting(containerEl)
			.setName("Enable Inline Highlighting")
			.setDesc("Enable syntax highlighting for inline code")
			.addToggle((toggle) =>
				toggle
					.setValue(this.plugin.settings.enableInlineHighlight)
					.onChange(async (value) => {
						this.plugin.settings.enableInlineHighlight = value;
						await this.plugin.saveSettings();
					})
			);

		new Setting(containerEl)
			.setName("Enable Caching")
			.setDesc("Cache highlighted code for better performance")
			.addToggle((toggle) =>
				toggle
					.setValue(this.plugin.settings.cacheEnabled)
					.onChange(async (value) => {
						this.plugin.settings.cacheEnabled = value;
						await this.plugin.saveSettings();
						if (!value) {
							this.plugin.clearCache();
						}
					})
			);
	}
}
```

# Bước 4: Code Block Parser

## src/parser.ts

```typescript
import { CodeBlockConfig, HighlightRange } from "./types";

export class CodeBlockParser {
	parseCodeBlockConfig(langString: string): CodeBlockConfig {
		const parts = langString.trim().split(/\s+/);
		const language = parts[0] || "text";

		const config: CodeBlockConfig = {
			language,
			highlightLines: [],
			showLineNumbers: false,
			startLineNumber: 1,
			fold: false,
			unfold: false,
			exclude: false,
		};

		// Parse parameters
		for (let i = 1; i < parts.length; i++) {
			const part = parts[i];

			if (part.startsWith("hl:")) {
				config.highlightLines = this.parseHighlightRanges(
					part.substring(3)
				);
			} else if (part.startsWith("ln:")) {
				const value = part.substring(3);
				if (value === "true") {
					config.showLineNumbers = true;
				} else if (value === "false") {
					config.showLineNumbers = false;
				} else if (!isNaN(Number(value))) {
					config.showLineNumbers = true;
					config.startLineNumber = Number(value);
				}
			} else if (part === "ln") {
				config.showLineNumbers = true;
			} else if (part.startsWith("title:") || part.startsWith("file:")) {
				const prefix = part.startsWith("title:") ? "title:" : "file:";
				let title = part.substring(prefix.length);

				// Handle quoted titles
				if (title.startsWith('"') && title.endsWith('"')) {
					title = title.slice(1, -1);
				}

				// Handle escaped quotes
				title = title.replace(/\\"/g, '"');
				config.title = title;
			} else if (part === "fold") {
				config.fold = true;
			} else if (part === "unfold") {
				config.unfold = true;
			} else if (part === "exclude") {
				config.exclude = true;
			}
		}

		return config;
	}

	private parseHighlightRanges(rangeString: string): number[] {
		const ranges: number[] = [];
		const parts = rangeString.split(",");

		for (const part of parts) {
			const trimmed = part.trim();

			if (trimmed.includes("-")) {
				// Range format: "1-5"
				const [start, end] = trimmed
					.split("-")
					.map((s) => parseInt(s.trim()));
				if (!isNaN(start) && !isNaN(end)) {
					for (let i = start; i <= end; i++) {
						ranges.push(i);
					}
				}
			} else {
				// Single line: "3"
				const line = parseInt(trimmed);
				if (!isNaN(line)) {
					ranges.push(line);
				}
			}
		}

		return ranges.sort((a, b) => a - b);
	}

	parseInlineCode(text: string): { lang: string; code: string } | null {
		const match = text.match(/^{(\w+)}\s*(.+)$/);
		if (match) {
			return {
				lang: match[1],
				code: match[2],
			};
		}
		return null;
	}
}
```

# Bước 5: Shiki Highlighter Wrapper

## src/highlighter.ts

```typescript
import { createHighlighter, type Highlighter } from "shiki";
import { ShikiPluginSettings, CacheEntry, ThemeMode } from "./types";

export class ShikiHighlighterManager {
	private highlighter: Highlighter | null = null;
	private cache = new Map<string, CacheEntry>();
	private settings: ShikiPluginSettings;
	private readonly CACHE_EXPIRY = 1000 * 60 * 30; // 30 minutes

	constructor(settings: ShikiPluginSettings) {
		this.settings = settings;
	}

	async initialize(): Promise<void> {
		try {
			this.highlighter = await createHighlighter({
				themes: this.settings.themes,
				langs: this.settings.languages,
			});
		} catch (error) {
			console.error("Failed to initialize Shiki highlighter:", error);
			throw error;
		}
	}

	async highlightCode(
		code: string,
		language: string,
		theme?: string
	): Promise<string> {
		if (!this.highlighter) {
			throw new Error("Highlighter not initialized");
		}

		const actualTheme = theme || this.getCurrentTheme();
		const cacheKey = this.generateCacheKey(code, language, actualTheme);

		// Check cache first
		if (this.settings.cacheEnabled && this.cache.has(cacheKey)) {
			const cached = this.cache.get(cacheKey)!;
			if (Date.now() - cached.timestamp < this.CACHE_EXPIRY) {
				return cached.html;
			}
		}

		try {
			const html = await this.highlighter.codeToHtml(code, {
				lang: language,
				theme: actualTheme,
				transformers: [],
			});

			// Cache the result
			if (this.settings.cacheEnabled) {
				this.cache.set(cacheKey, {
					html,
					timestamp: Date.now(),
				});
			}

			return html;
		} catch (error) {
			console.warn(
				`Failed to highlight code for language ${language}:`,
				error
			);
			// Fallback to plain text
			return this.highlighter.codeToHtml(code, {
				lang: "text",
				theme: actualTheme,
			});
		}
	}

	async highlightInlineCode(code: string, language: string): Promise<string> {
		if (!this.highlighter) {
			throw new Error("Highlighter not initialized");
		}

		try {
			const html = await this.highlighter.codeToHtml(code, {
				lang: language,
				theme: this.getCurrentTheme(),
				transformers: [],
			});

			// Extract just the code content without the pre wrapper
			const match = html.match(
				/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/s
			);
			return match ? match[1] : code;
		} catch (error) {
			console.warn(
				`Failed to highlight inline code for language ${language}:`,
				error
			);
			return code;
		}
	}

	getCurrentTheme(): string {
		const isDark = document.body.classList.contains("theme-dark");
		return isDark
			? this.settings.defaultDarkTheme
			: this.settings.defaultLightTheme;
	}

	updateSettings(settings: ShikiPluginSettings): void {
		this.settings = settings;
	}

	clearCache(): void {
		this.cache.clear();
	}

	private generateCacheKey(
		code: string,
		language: string,
		theme: string
	): string {
		const hash = this.simpleHash(code);
		return `${language}-${theme}-${hash}`;
	}

	private simpleHash(str: string): number {
		let hash = 0;
		for (let i = 0; i < str.length; i++) {
			const char = str.charCodeAt(i);
			hash = (hash << 5) - hash + char;
			hash = hash & hash; // Convert to 32bit integer
		}
		return hash;
	}

	async loadLanguage(language: string): Promise<void> {
		if (!this.highlighter) return;

		try {
			await this.highlighter.loadLanguage(language);
			if (!this.settings.languages.includes(language)) {
				this.settings.languages.push(language);
			}
		} catch (error) {
			console.warn(`Failed to load language ${language}:`, error);
		}
	}

	async loadTheme(theme: string): Promise<void> {
		if (!this.highlighter) return;

		try {
			await this.highlighter.loadTheme(theme);
			if (!this.settings.themes.includes(theme)) {
				this.settings.themes.push(theme);
			}
		} catch (error) {
			console.warn(`Failed to load theme ${theme}:`, error);
		}
	}
}
```

# Bước 6: Custom Transformers

## src/transformers.ts

```typescript
import { CodeBlockConfig } from "./types";

export class CustomTransformers {
	static createLineHighlightTransformer(config: CodeBlockConfig) {
		return {
			name: "line-highlight",
			line(node: any, lineNumber: number) {
				if (config.highlightLines.includes(lineNumber)) {
					node.properties = node.properties || {};
					node.properties.class =
						(node.properties.class || "") + " highlighted-line";
				}
			},
		};
	}

	static createLineNumberTransformer(config: CodeBlockConfig) {
		return {
			name: "line-numbers",
			pre(node: any) {
				if (config.showLineNumbers) {
					node.properties = node.properties || {};
					node.properties.class =
						(node.properties.class || "") + " shiki-line-numbers";
				}
			},
			line(node: any, lineNumber: number) {
				if (config.showLineNumbers) {
					const actualLineNumber =
						lineNumber + config.startLineNumber - 1;
					node.children.unshift({
						type: "element",
						tagName: "span",
						properties: {
							class: "line-number",
							"data-line": actualLineNumber.toString(),
						},
						children: [
							{
								type: "text",
								value: actualLineNumber
									.toString()
									.padStart(3, " "),
							},
						],
					});
				}
			},
		};
	}

	static createTitleTransformer(config: CodeBlockConfig) {
		return {
			name: "title",
			pre(node: any) {
				if (config.title) {
					node.properties = node.properties || {};
					node.properties["data-title"] = config.title;
					node.properties.class =
						(node.properties.class || "") + " shiki-with-title";
				}
			},
		};
	}

	static createFoldingTransformer(config: CodeBlockConfig) {
		return {
			name: "folding",
			pre(node: any) {
				if (config.fold || config.unfold) {
					node.properties = node.properties || {};
					node.properties.class =
						(node.properties.class || "") + " shiki-foldable";

					if (config.fold) {
						node.properties.class += " shiki-folded";
					}
				}
			},
		};
	}
}
```

# Bước 7: Main Plugin Class

## src/main.ts

```typescript
import { Plugin, MarkdownPostProcessorContext } from "obsidian";
import { ShikiHighlighterManager } from "./highlighter";
import { CodeBlockParser } from "./parser";
import { CustomTransformers } from "./transformers";
import { ShikiSettingTab, DEFAULT_SETTINGS } from "./settings";
import { ShikiPluginSettings } from "./types";

export default class ShikiCustomPlugin extends Plugin {
	settings: ShikiPluginSettings;
	highlighter: ShikiHighlighterManager;
	parser: CodeBlockParser;

	async onload() {
		await this.loadSettings();

		// Initialize components
		this.highlighter = new ShikiHighlighterManager(this.settings);
		this.parser = new CodeBlockParser();

		// Initialize highlighter
		try {
			await this.highlighter.initialize();
			console.log("Shiki highlighter initialized successfully");
		} catch (error) {
			console.error("Failed to initialize Shiki highlighter:", error);
			return;
		}

		// Register processors
		this.registerMarkdownPostProcessor(this.processCodeBlocks.bind(this));

		if (this.settings.enableInlineHighlight) {
			this.registerMarkdownPostProcessor(
				this.processInlineCode.bind(this)
			);
		}

		// Add settings tab
		this.addSettingTab(new ShikiSettingTab(this.app, this));

		// Register theme change event
		this.registerEvent(
			this.app.workspace.on("css-change", () => {
				this.refreshAllCodeBlocks();
			})
		);

		// Register commands
		this.addCommand({
			id: "refresh-highlighting",
			name: "Refresh Code Highlighting",
			callback: () => this.refreshAllCodeBlocks(),
		});

		this.addCommand({
			id: "clear-cache",
			name: "Clear Highlighting Cache",
			callback: () => {
				this.highlighter.clearCache();
				new Notice("Highlighting cache cleared");
			},
		});
	}

	async processCodeBlocks(
		element: HTMLElement,
		ctx: MarkdownPostProcessorContext
	) {
		const codeBlocks = element.querySelectorAll("pre > code");

		for (const codeElement of codeBlocks) {
			const preElement = codeElement.parentElement;
			if (!preElement) continue;

			// Skip if already processed
			if (preElement.hasClass("shiki-processed")) continue;

			try {
				await this.highlightCodeBlock(
					codeElement as HTMLElement,
					preElement
				);
				preElement.addClass("shiki-processed");
			} catch (error) {
				console.error("Error processing code block:", error);
			}
		}
	}

	async processInlineCode(element: HTMLElement) {
		const inlineCodes = element.querySelectorAll("code:not(pre > code)");

		for (const codeElement of inlineCodes) {
			if (codeElement.hasClass("shiki-inline-processed")) continue;

			const text = codeElement.textContent || "";
			const parsed = this.parser.parseInlineCode(text);

			if (parsed) {
				try {
					const highlighted =
						await this.highlighter.highlightInlineCode(
							parsed.code,
							parsed.lang
						);
					codeElement.innerHTML = highlighted;
					codeElement.addClass("shiki-inline-processed");
				} catch (error) {
					console.error("Error processing inline code:", error);
				}
			}
		}
	}

	private async highlightCodeBlock(
		codeElement: HTMLElement,
		preElement: HTMLElement
	) {
		const code = codeElement.textContent || "";
		const langClass = codeElement.className.match(/language-(\S+)/);
		const langString = langClass ? langClass[1] : "";

		// Parse configuration
		const config = this.parser.parseCodeBlockConfig(langString);

		// Skip if excluded
		if (config.exclude) return;

		try {
			// Get highlighted HTML
			const highlightedHtml = await this.highlighter.highlightCode(
				code,
				config.language
			);

			// Parse the HTML to extract and modify
			const tempDiv = document.createElement("div");
			tempDiv.innerHTML = highlightedHtml;

			const shikiPre = tempDiv.querySelector("pre");
			const shikiCode = tempDiv.querySelector("code");

			if (!shikiPre || !shikiCode) return;

			// Apply transformations
			this.applyCodeBlockTransformations(shikiPre, config);

			// Replace original content
			preElement.innerHTML = shikiPre.innerHTML;
			preElement.className = shikiPre.className;

			// Store original data for refresh
			preElement.setAttribute("data-original-code", code);
			preElement.setAttribute("data-language", config.language);
			preElement.setAttribute("data-config", langString);
		} catch (error) {
			console.error("Error highlighting code block:", error);
		}
	}

	private applyCodeBlockTransformations(
		preElement: HTMLElement,
		config: CodeBlockConfig
	) {
		// Add line numbers
		if (config.showLineNumbers || this.settings.enableLineNumbers) {
			this.addLineNumbers(preElement, config.startLineNumber);
		}

		// Add line highlighting
		if (config.highlightLines.length > 0) {
			this.addLineHighlighting(preElement, config.highlightLines);
		}

		// Add title
		if (config.title) {
			this.addTitle(preElement, config.title);
		}

		// Add folding capability
		if (config.fold || config.unfold) {
			this.addFoldingCapability(preElement, config.fold);
		}
	}

	private addLineNumbers(preElement: HTMLElement, startNumber: number = 1) {
		preElement.addClass("shiki-line-numbers");
		const lines = preElement.querySelectorAll(".line");

		lines.forEach((line, index) => {
			const lineNumber = document.createElement("span");
			lineNumber.className = "line-number";
			lineNumber.textContent = (startNumber + index).toString();
			line.prepend(lineNumber);
		});
	}

	private addLineHighlighting(
		preElement: HTMLElement,
		highlightLines: number[]
	) {
		const lines = preElement.querySelectorAll(".line");

		lines.forEach((line, index) => {
			if (highlightLines.includes(index + 1)) {
				line.addClass("highlighted-line");
			}
		});
	}

	private addTitle(preElement: HTMLElement, title: string) {
		const titleElement = document.createElement("div");
		titleElement.className = "shiki-title";
		titleElement.textContent = title;

		preElement.addClass("shiki-with-title");
		preElement.prepend(titleElement);
	}

	private addFoldingCapability(
		preElement: HTMLElement,
		folded: boolean = false
	) {
		preElement.addClass("shiki-foldable");

		if (folded) {
			preElement.addClass("shiki-folded");
		}

		// Add click handler for folding
		const titleElement = preElement.querySelector(".shiki-title");
		if (titleElement) {
			titleElement.addEventListener("click", () => {
				preElement.toggleClass("shiki-folded");
			});
			titleElement.style.cursor = "pointer";
		}
	}

	private refreshAllCodeBlocks() {
		// Find all processed code blocks and re-highlight them
		const processedBlocks = document.querySelectorAll(
			"pre.shiki-processed"
		);

		processedBlocks.forEach(async (preElement) => {
			const originalCode = preElement.getAttribute("data-original-code");
			const language = preElement.getAttribute("data-language");
			const configString = preElement.getAttribute("data-config");

			if (originalCode && language) {
				preElement.removeClass("shiki-processed");

				const codeElement = preElement.querySelector("code");
				if (codeElement) {
					codeElement.textContent = originalCode;
					codeElement.className = `language-${
						configString || language
					}`;

					await this.highlightCodeBlock(
						codeElement,
						preElement as HTMLElement
					);
				}
			}
		});
	}

	async loadSettings() {
		this.settings = Object.assign(
			{},
			DEFAULT_SETTINGS,
			await this.loadData()
		);
	}

	async saveSettings() {
		await this.saveData(this.settings);
		this.highlighter?.updateSettings(this.settings);
	}

	clearCache() {
		this.highlighter?.clearCache();
	}

	onunload() {
		this.clearCache();
	}
}
```

# Bước 8: CSS Styling

## styles.css

```css
/* Base code block styling */
.shiki {
	margin: 1em 0;
	border-radius: 6px;
	overflow: hidden;
	position: relative;
}

/* Title styling */
.shiki-with-title {
	border-radius: 0 0 6px 6px;
}

.shiki-title {
	background: var(--background-secondary);
	color: var(--text-normal);
	padding: 8px 16px;
	font-size: 14px;
	font-weight: 600;
	border-bottom: 1px solid var(--background-modifier-border);
	border-radius: 6px 6px 0 0;
	position: relative;
}

.shiki-foldable .shiki-title::after {
	content: "▼";
	position: absolute;
	right: 16px;
	transition: transform 0.2s ease;
}

.shiki-folded .shiki-title::after {
	transform: rotate(-90deg);
}

/* Line numbers styling */
.shiki-line-numbers {
	position: relative;
	padding-left: 3.5em;
}

.line-number {
	position: absolute;
	left: 0;
	width: 3em;
	text-align: right;
	padding-right: 1em;
	color: var(--text-muted);
	user-select: none;
	font-family: var(--font-monospace);
	font-size: inherit;
	line-height: inherit;
}

/* Line highlighting */
.highlighted-line {
	background-color: var(--background-modifier-hover);
	display: block;
	margin: 0 -1em;
	padding: 0 1em;
	position: relative;
}

.shiki-line-numbers .highlighted-line {
	margin-left: -3.5em;
	padding-left: 3.5em;
}

/* Folding animation */
.shiki-foldable .shiki {
	transition: max-height 0.3s ease;
	overflow: hidden;
}

.shiki-folded .shiki > code {
	display: none;
}

/* Inline code highlighting */
code.shiki-inline-processed {
	background: var(--code-background);
	padding: 2px 4px;
	border-radius: 3px;
	font-family: var(--font-monospace);
}

/* Dark/Light theme adjustments */
.theme-dark .shiki {
	border: 1px solid var(--background-modifier-border);
}

.theme-light .shiki {
	border: 1px solid var(--background-modifier-border);
}

/* Mobile responsive */
@media (max-width: 768px) {
	.shiki-line-numbers {
		padding-left: 2.5em;
	}

	.line-number {
		width: 2em;
		font-size: 0.85em;
	}

	.shiki- .shiki-title {
		padding: 6px 12px;
		font-size: 13px;
	}

	.highlighted-line {
		margin: 0 -0.5em;
		padding: 0 0.5em;
	}

	.shiki-line-numbers .highlighted-line {
		margin-left: -2.5em;
		padding-left: 2.5em;
	}
}

/* Scroll handling for long code blocks */
.shiki pre {
	overflow-x: auto;
	max-width: 100%;
}

/* Loading state */
.shiki-loading {
	background: var(--background-secondary);
	color: var(--text-muted);
	padding: 1em;
	border-radius: 6px;
	text-align: center;
}

.shiki-loading::after {
	content: "...";
	animation: loading-dots 1.5s infinite;
}

@keyframes loading-dots {
	0%,
	20% {
		content: "";
	}
	40% {
		content: ".";
	}
	60% {
		content: "..";
	}
	80%,
	100% {
		content: "...";
	}
}

/* Error state */
.shiki-error {
	background: var(--background-modifier-error);
	color: var(--text-error);
	padding: 1em;
	border-radius: 6px;
	border-left: 4px solid var(--text-error);
}

/* Copy button (optional enhancement) */
.shiki-container {
	position: relative;
}

.shiki-copy-button {
	position: absolute;
	top: 8px;
	right: 8px;
	background: var(--interactive-normal);
	border: 1px solid var(--background-modifier-border);
	color: var(--text-muted);
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 12px;
	cursor: pointer;
	opacity: 0;
	transition: opacity 0.2s ease;
}

.shiki-container:hover .shiki-copy-button {
	opacity: 1;
}

.shiki-copy-button:hover {
	background: var(--interactive-hover);
	color: var(--text-normal);
}

/* Language badge */
.shiki-language-badge {
	position: absolute;
	top: 8px;
	right: 8px;
	background: var(--background-secondary-alt);
	color: var(--text-muted);
	padding: 2px 8px;
	border-radius: 12px;
	font-size: 11px;
	font-weight: 500;
	text-transform: uppercase;
	letter-spacing: 0.5px;
}

/* Focus and accessibility */
.shiki:focus-within {
	outline: 2px solid var(--interactive-accent);
	outline-offset: 2px;
}

.shiki-title:focus {
	outline: 2px solid var(--interactive-accent);
	outline-offset: -2px;
}

/* Print styles */
@media print {
	.shiki {
		border: 1px solid #ccc;
		break-inside: avoid;
	}

	.shiki-copy-button,
	.shiki-language-badge {
		display: none;
	}

	.highlighted-line {
		background-color: #f0f0f0 !important;
	}
}
```
